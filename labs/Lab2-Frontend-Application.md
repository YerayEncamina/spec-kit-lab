# ğŸ—£ï¸ Lab 2: The Voice of the Narrator

## Building a Text Adventure Frontend with GitHub Spec Kit

### Overview

With your REST API forged and running, it's time to practice the arts of invocation. In this lab, you will build a **frontend application** that connects to your adventure API and provides an interactive text-based adventure experience.

You'll work within the **same Spec Kit project** from Lab 1, sharing the OpenAPI specification to generate type-safe API clients.

**Estimated Time:** 1.5-2 hours

**Technologies:**

- Frontend framework of your choice (React, Vue, Svelte, or Vanilla JS)
- HTTP client for API communication
- **OpenAPI TypeScript codegen** for type-safe API integration
- Development Methodology: **Spec-Driven Development (SDD)**

---

## Prerequisites

Before starting this lab, ensure you have:

- [ ] Completed Lab 1 with a running REST API
- [ ] The `openapi.json` (or `openapi.yaml`) exported to the project root (see Lab 1, Step 5)
- [ ] Node.js (v18+) installed
- [ ] **Visual Studio Code** installed
- [ ] **GitHub Copilot** extension installed and activated in VS Code
- [ ] The Spec Kit CLI installed (`specify version` to verify)
- [ ] Your API running at `http://localhost:3000` (or your configured port)

---

## Step 1: Set Up Frontend in the Monorepo

You'll create the frontend within the same project from Lab 1, sharing the OpenAPI specification:

```bash
# Navigate to your project root
# You should already be at the root where specs/ and packages/ exist

# Create the frontend package directory
mkdir -p packages/frontend
cd packages/frontend

# Verify the OpenAPI spec is available at project root
ls ../../openapi.json  # or openapi.yaml
```

> **ğŸ“¦ Shared Project:** By working in the same Spec Kit project, the frontend can directly access the OpenAPI spec generated by the API. This ensures your frontend types always match your backend contract.

### Project Structure After This Lab

```
project-root/
â”œâ”€â”€ specs/              # Shared specifications
â”œâ”€â”€ memory/             # Project context
â”œâ”€â”€ openapi.json        # API contract (from Lab 1)
â”œâ”€â”€ packages/
â”‚   â”œâ”€â”€ api/            # Backend API (Lab 1)
â”‚   â””â”€â”€ frontend/       # Frontend app (this lab)
â”‚       â”œâ”€â”€ src/
â”‚       â”‚   â”œâ”€â”€ api/    # Generated API client
â”‚       â”‚   â””â”€â”€ ...
â”‚       â””â”€â”€ package.json
â””â”€â”€ .env.example
```

---

## Step 2: Generate Typed API Client from OpenAPI

Generate TypeScript types and an API client from the OpenAPI specification. This ensures your frontend is always in sync with the backend contract.

### Install OpenAPI TypeScript Generator

```bash
# From packages/frontend directory
npm init -y

# Install openapi-typescript for type generation
npm install -D openapi-typescript

# Install a fetch-based client generator (recommended)
npm install -D openapi-fetch
```

### Generate Types from OpenAPI Spec

```bash
# Generate TypeScript types from the shared OpenAPI spec
npx openapi-typescript ../../openapi.json -o ./src/api/schema.d.ts

# Or if using YAML
npx openapi-typescript ../../openapi.yaml -o ./src/api/schema.d.ts
```

### Create API Client

Create `src/api/client.ts`:

```typescript
import createClient from "openapi-fetch";
import type { paths } from "./schema";

// API base URL from environment variable
const API_URL = import.meta.env.VITE_API_URL || "http://localhost:3000/api";

// Create typed API client
export const api = createClient<paths>({ baseUrl: API_URL });

// Example usage:
// const { data, error } = await api.GET("/adventures");
// const { data, error } = await api.POST("/adventures", { body: { name: "My Adventure" } });
```

### Add npm Scripts for Regeneration

Update `package.json` to easily regenerate types when the API changes:

```json
{
  "scripts": {
    "generate:api": "openapi-typescript ../../openapi.json -o ./src/api/schema.d.ts",
    "dev": "vite",
    "build": "npm run generate:api && vite build"
  }
}
```

### Configure Environment Variables

Create `.env` file in `packages/frontend`:

```bash
# .env
VITE_API_URL=http://localhost:3000/api
```

> **ğŸ”„ Keep in Sync:** Whenever you update the API in Lab 1, re-run `npm run generate:api` to update your frontend types. This ensures compile-time safety between your frontend and backend.

---

## ğŸ’¬ Using Spec Kit Commands in VS Code

All `/speckit.*` commands are executed through the **GitHub Copilot Chat panel** in VS Code:

1. **Open the Chat Panel**: Press `Ctrl+Shift+I` (Windows/Linux) or `Cmd+Shift+I` (Mac), or click the Copilot icon in the sidebar
2. **Type the command**: Enter the `/speckit.*` command followed by your description
3. **Press Enter**: Copilot will process the command and generate the appropriate files
4. **Review the output**: Check the generated specifications and approve any file changes

> **ğŸ’¡ Tip:** Make sure you have the project folder open in VS Code before running commands. The commands work on the current workspace.

---

## Step 3: Extend the Project Constitution

The project already has API-focused principles from Lab 1. Now extend the constitution with frontend-specific guidelines:

```
/speckit.constitution Extend the existing principles with frontend-specific guidelines:
- Accessibility: Interface must be keyboard navigable and screen-reader friendly
- Simplicity: Focus on functionality over visual complexity
- Responsiveness: Interface must work on mobile and desktop
- Error handling: All API errors must be displayed gracefully to users
- Type safety: Use generated API types for all backend communication
- Documentation: All components and functions must be documented
```

> **ğŸ“ Note:** This extends the constitution created in Lab 1, which already includes principles for RESTful design, OpenAPI documentation, testability, simplicity, and performance. The combined principles guide both backend and frontend development.

---

## Step 4: Implement Features Using Spec Kit Workflow

For each feature, follow the complete Spec Kit workflow:

1. **Specify** â†’ Create the feature specification
2. **Plan** â†’ Generate implementation plan
3. **Tasks** â†’ Break down into actionable tasks
4. **Implement** â†’ Execute the implementation

> **âš ï¸ Important:** Complete the full workflow for each feature before moving to the next one.

---

### ğŸ“‹ Recommended Implementation Order

| Order | Feature                 | Reason                |
| ----- | ----------------------- | --------------------- |
| 1     | Adventure Dashboard     | Core navigation       |
| 2     | Character Management UI | Depends on adventures |
| 3     | Game Interface          | Main gameplay         |
| 4     | Inventory UI            | Enhances gameplay     |
| 5     | Quest Log               | Complete experience   |

---

### Feature 1: Adventure Dashboard

> **âš ï¸ Before starting:** Make sure you're on the main branch with latest changes:
>
> ```bash
> git checkout main && git pull
> ```

#### Step 4.1.1 - Specify

```
/speckit.specify Build an adventure dashboard where users can:
- View list of their existing adventures
- Create a new adventure with a name
- Select an adventure to continue playing
- Delete an adventure with confirmation
- Display adventure metadata (creation date, current scene, progress)
- Show loading skeleton while fetching data
```

> **ğŸ“ Review:** Check the generated specification in `specs/` folder. Verify it captures all dashboard requirements and user interactions.

#### Step 4.1.2 - Plan

**For React:**

```
/speckit.plan Use React 18 with TypeScript. Use Vite for build tooling. Use React Router for navigation. Use TanStack Query (React Query) for API state management. Use Tailwind CSS for styling. Store API URL in environment variables. Create dashboard components with adventure list.
```

**For Vue:**

```
/speckit.plan Use Vue 3 with TypeScript and Composition API. Use Vite for build tooling. Use Vue Router for navigation. Use Pinia for state management. Use Tailwind CSS for styling. Store API URL in environment variables. Create dashboard components with adventure list.
```

**For Vanilla JavaScript:**

```
/speckit.plan Use vanilla HTML, CSS, and JavaScript. Use Vite for build tooling. Use native fetch API for HTTP requests. Use CSS custom properties for theming. Create modular JavaScript with ES modules. Store API URL in environment variables. Create dashboard components with adventure list.
```

> **ğŸ“ Review:** Verify the plan matches your chosen framework and includes component structure, API integration approach, and state management.

#### Step 4.1.3 - Tasks

```
/speckit.tasks
```

> **ğŸ“ Review:** Ensure tasks cover component creation, API hooks/services, loading states, and error handling.

#### Step 4.1.4 - Implement

```
/speckit.implement
```

> **ğŸ“ Review:** Check generated components for proper API integration, loading states, and user feedback.

#### âœ… Checkpoint: Verify Adventure Dashboard

> **âš ï¸ Before testing:** Make sure both servers are running!

```bash
# Terminal 1: Start the backend API (from packages/api)
cd packages/api
npm run dev   # or: dotnet run

# Terminal 2: Start the frontend dev server (from packages/frontend)
cd packages/frontend
npm run dev
```

Open http://localhost:5173 in your browser and verify:

- [ ] Adventures list loads from API
- [ ] Can create new adventure
- [ ] Can select adventure to play
- [ ] Delete shows confirmation

#### ğŸ”€ Git: Commit and Merge Feature 1

**Option A: Using VS Code**

1. Open **Source Control** panel (`Ctrl+Shift+G` / `Cmd+Shift+G`)
2. Review changed files in the "Changes" section
3. Click `+` next to each file (or `+` on "Changes" header to stage all)
4. Enter commit message: `feat: implement adventure dashboard`
5. Click **Commit** button (checkmark icon)
6. Click **Sync Changes** to push to the current branch
7. Click **Create Pull Request** in the Source Control panel (or use GitHub extension)
8. Review and merge the PR on GitHub, then pull main locally

**Option B: Using Terminal**

```bash
git add .
git commit -m "feat: implement adventure dashboard

- Add adventure list with API integration
- Implement create/delete adventure flows
- Add loading skeletons and error states
- Configure environment variables"

# Push to the current feature branch (created by Spec Kit)
git push

# Create PR using GitHub CLI
gh pr create --title "feat: implement adventure dashboard" --body "Implements adventure dashboard with list view, create/delete flows, and API integration."

# Merge PR (after review/approval)
gh pr merge --squash --delete-branch
```

---

### Feature 2: Character Management UI

> **âš ï¸ Before starting:** Make sure you're on the main branch with latest changes:
>
> ```bash
> git checkout main && git pull
> ```

#### Step 4.2.1 - Specify

```
/speckit.specify Build a character management interface:
- Character creation form with name input
- Attribute allocation system (STR, DEX, INT, CON, CHA)
- Point-buy or dice roll options for attributes
- Display calculated modifiers next to each attribute
- Character sheet view showing all stats
- Edit character functionality
- Character selection for adventures
```

> **ğŸ“ Review:** Check that the specification includes form validation rules and modifier calculation display.

#### Step 4.2.2 - Plan

```
/speckit.plan Continue with the existing tech stack. Create character form with attribute inputs. Implement modifier calculation display. Add dice roll integration for stat generation. Create character sheet component.
```

> **ğŸ“ Review:** Verify the plan includes form validation, dice roll API integration, and character sheet layout.

#### Step 4.2.3 - Tasks

```
/speckit.tasks
```

> **ğŸ“ Review:** Ensure tasks cover form components, validation, dice integration, and character display.

#### Step 4.2.4 - Implement

```
/speckit.implement
```

> **ğŸ“ Review:** Verify form validation, modifier calculations, and dice roll integration work correctly.

#### âœ… Checkpoint: Verify Character Management

> **âš ï¸ Ensure both servers are running** (see Feature 1 checkpoint for start commands)

Open http://localhost:5173 in your browser and verify:

- [ ] Character creation form works
- [ ] Attributes can be allocated
- [ ] Modifiers display correctly
- [ ] Character sheet shows all stats

#### ğŸ”€ Git: Commit and Merge Feature 2

**Option A: Using VS Code**

1. Open **Source Control** panel (`Ctrl+Shift+G`)
2. Stage all changes with `+`
3. Commit message: `feat: implement character management UI`
4. Click **Commit** then **Sync Changes**
5. Create a Pull Request and merge to main

**Option B: Using Terminal**

```bash
git add .
git commit -m "feat: implement character management UI

- Add character creation form with validation
- Implement attribute allocation system
- Display calculated modifiers
- Create character sheet view"

# Push to the current feature branch (created by Spec Kit)
git push

# Create PR using GitHub CLI
gh pr create --title "feat: implement character management UI" --body "Implements character management with creation form, attribute allocation, and character sheet view."

# Merge PR (after review/approval)
gh pr merge --squash --delete-branch
```

---

### Feature 3: Game Interface

> **âš ï¸ Before starting:** Make sure you're on the main branch with latest changes:
>
> ```bash
> git checkout main && git pull
> ```

#### Step 4.3.1 - Specify

```
/speckit.specify Build the main text adventure game interface:
- Narrative text display area with scrollable history
- Player input field for commands/choices
- Current scene description display
- Character status panel (HP, conditions, equipped items)
- Action buttons for common actions (attack, flee, use item)
- Combat mode with turn indicators
- Dice roll results display with animation
```

> **ğŸ“ Review:** Check that the specification includes all UI components and interaction patterns.

#### Step 4.3.2 - Plan

```
/speckit.plan Continue with the existing tech stack. Create game screen with narrative display. Implement command input with history. Add character status sidebar. Create combat UI with turn indicator. Add dice roll animation component.
```

> **ğŸ“ Review:** Verify the plan includes narrative scrolling, command history, and combat state management.

#### Step 4.3.3 - Tasks

```
/speckit.tasks
```

> **ğŸ“ Review:** Ensure tasks cover narrative display, input handling, combat UI, and dice animations.

#### Step 4.3.4 - Implement

```
/speckit.implement
```

> **ğŸ“ Review:** Verify narrative scrolling, command processing, combat mode, and dice roll display.

#### âœ… Checkpoint: Verify Game Interface

> **âš ï¸ Ensure both servers are running** (see Feature 1 checkpoint for start commands)

Open http://localhost:5173 in your browser and verify:

- [ ] Narrative text displays and scrolls
- [ ] Commands can be entered
- [ ] Character status shows correctly
- [ ] Combat mode works

#### ğŸ”€ Git: Commit and Merge Feature 3

**Option A: Using VS Code**

1. Open **Source Control** panel (`Ctrl+Shift+G`)
2. Stage all changes with `+`
3. Commit message: `feat: implement main game interface`
4. Click **Commit** then **Sync Changes**
5. Create a Pull Request and merge to main

**Option B: Using Terminal**

```bash
git add .
git commit -m "feat: implement main game interface

- Add narrative display with scrollable history
- Implement command input with history
- Create character status panel
- Add combat mode with turn indicators
- Implement dice roll animations"

# Push to the current feature branch (created by Spec Kit)
git push

# Create PR using GitHub CLI
gh pr create --title "feat: implement main game interface" --body "Implements main game interface with narrative display, command input, status panel, and combat mode."

# Merge PR (after review/approval)
gh pr merge --squash --delete-branch
```

---

### Feature 4: Inventory UI

> **âš ï¸ Before starting:** Make sure you're on the main branch with latest changes:
>
> ```bash
> git checkout main && git pull
> ```

#### Step 4.4.1 - Specify

```
/speckit.specify Build an inventory management interface:
- Grid or list view of inventory items
- Item details on hover/click
- Drag-and-drop or button-based equip/unequip
- Stack quantity display for stackable items
- Equipment slots visualization
- Use item functionality
- Sort and filter options
```

> **ğŸ“ Review:** Check that the specification covers all inventory interactions and display modes.

#### Step 4.4.2 - Plan

```
/speckit.plan Continue with the existing tech stack. Create inventory grid component. Implement item detail modal/tooltip. Add equipment slot visualization. Create equip/unequip functionality.
```

> **ğŸ“ Review:** Verify the plan includes grid/list toggle, item interactions, and equipment slot mapping.

#### Step 4.4.3 - Tasks

```
/speckit.tasks
```

> **ğŸ“ Review:** Ensure tasks cover inventory display, item details, drag-drop/buttons, and filtering.

#### Step 4.4.4 - Implement

```
/speckit.implement
```

> **ğŸ“ Review:** Verify item display, detail views, equip/unequip actions, and sort/filter functionality.

#### âœ… Checkpoint: Verify Inventory UI

> **âš ï¸ Ensure both servers are running** (see Feature 1 checkpoint for start commands)

Open http://localhost:5173 in your browser and verify:

- [ ] Items display in grid/list
- [ ] Item details show on interaction
- [ ] Equip/unequip works
- [ ] Stacks show quantities

#### ğŸ”€ Git: Commit and Merge Feature 4

**Option A: Using VS Code**

1. Open **Source Control** panel (`Ctrl+Shift+G`)
2. Stage all changes with `+`
3. Commit message: `feat: implement inventory UI`
4. Click **Commit** then **Sync Changes**
5. Create a Pull Request and merge to main

**Option B: Using Terminal**

```bash
git add .
git commit -m "feat: implement inventory UI

- Add inventory grid/list view
- Implement item details modal
- Create equipment slots visualization
- Add equip/unequip functionality
- Implement sort and filter options"

# Push to the current feature branch (created by Spec Kit)
git push

# Create PR using GitHub CLI
gh pr create --title "feat: implement inventory UI" --body "Implements inventory interface with grid/list view, item details, equipment slots, and filtering."

# Merge PR (after review/approval)
gh pr merge --squash --delete-branch
```

---

### Feature 5: Quest Log

> **âš ï¸ Before starting:** Make sure you're on the main branch with latest changes:
>
> ```bash
> git checkout main && git pull
> ```

#### Step 4.5.1 - Specify

```
/speckit.specify Build a quest tracking interface:
- List of active quests
- Quest details view with objectives
- Progress indicators for each stage
- Completed quests history
- Quest rewards display
- Filter by quest status (active, completed, failed)
```

> **ğŸ“ Review:** Check that the specification includes all quest states and progress tracking requirements.

#### Step 4.5.2 - Plan

```
/speckit.plan Continue with the existing tech stack. Create quest list component with filters. Implement quest detail view. Add progress indicators. Create completed quests section.
```

> **ğŸ“ Review:** Verify the plan includes filter logic, progress visualization, and quest history handling.

#### Step 4.5.3 - Tasks

```
/speckit.tasks
```

> **ğŸ“ Review:** Ensure tasks cover quest list, detail view, progress bars, and filtering.

#### Step 4.5.4 - Implement

```
/speckit.implement
```

> **ğŸ“ Review:** Verify quest list, details, progress indicators, and filters work correctly.

#### âœ… Checkpoint: Verify Quest Log

> **âš ï¸ Ensure both servers are running** (see Feature 1 checkpoint for start commands)

Open http://localhost:5173 in your browser and verify:

- [ ] Quest list displays
- [ ] Quest details show objectives
- [ ] Progress indicators work
- [ ] Filters function correctly

#### ğŸ”€ Git: Commit and Merge Feature 5

**Option A: Using VS Code**

1. Open **Source Control** panel (`Ctrl+Shift+G`)
2. Stage all changes with `+`
3. Commit message: `feat: implement quest log UI`
4. Click **Commit** then **Sync Changes**
5. Create a Pull Request and merge to main

**Option B: Using Terminal**

```bash
git add .
git commit -m "feat: implement quest log UI

- Add quest list with status filters
- Implement quest detail view
- Create progress indicators
- Add completed quests history"

# Push to the current feature branch (created by Spec Kit)
git push

# Create PR using GitHub CLI
gh pr create --title "feat: implement quest log UI" --body "Implements quest log with list view, details, progress indicators, and history."

# Merge PR (after review/approval)
gh pr merge --squash --delete-branch
```

---

---

## Step 5: Quality Checklist

Ensure your frontend implements:

- [ ] **Input Validation**
  - [ ] Client-side form validation
  - [ ] Sanitized user input display
  - [ ] XSS prevention

- [ ] **Error Handling**
  - [ ] API errors handled gracefully
  - [ ] Graceful degradation
  - [ ] User-friendly error messages

- [ ] **Performance**
  - [ ] Loading states during API calls
  - [ ] Efficient re-renders
  - [ ] Responsive design

---

## Minimum Functional Requirements Checklist

Ensure your frontend implements:

- [ ] **Adventure Management**
  - [ ] List adventures
  - [ ] Create new adventure
  - [ ] Select adventure to play
  - [ ] Delete adventure

- [ ] **Character Interface**
  - [ ] Create character with attributes
  - [ ] View character sheet
  - [ ] Attribute modifiers displayed

- [ ] **Game Interface**
  - [ ] Narrative text display
  - [ ] Player input
  - [ ] Action responses
  - [ ] Dice roll display

- [ ] **Inventory** (Optional but valued)
  - [ ] View items
  - [ ] Equip/unequip

- [ ] **Quests** (Optional but valued)
  - [ ] Quest list
  - [ ] Quest progress

---

## Example Game Flow

Here's what a typical interaction might look like:

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  ğŸ° The Adventure Begins                                    â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                             â”‚
â”‚  You stand at the entrance of a dark cave. The wind        â”‚
â”‚  howls behind you, carrying whispers of treasure and       â”‚
â”‚  danger within.                                             â”‚
â”‚                                                             â”‚
â”‚  A faint glow emanates from deeper inside the cavern.      â”‚
â”‚                                                             â”‚
â”‚  What do you do?                                            â”‚
â”‚                                                             â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  [Enter Cave]  [Search Outside]  [Check Inventory]         â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                             â”‚
â”‚  > Enter the cave carefully                                 â”‚
â”‚                                                    [Send]   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Aldric the Brave â”‚
â”‚ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ â”‚
â”‚ HP: 24/24        â”‚
â”‚ STR: 16 (+3)     â”‚
â”‚ DEX: 14 (+2)     â”‚
â”‚ INT: 10 (+0)     â”‚
â”‚ CON: 15 (+2)     â”‚
â”‚ CHA: 12 (+1)     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## Evaluation Criteria

Your implementation will be evaluated on:

| Criteria           | Weight |
| ------------------ | ------ |
| API Integration    | 30%    |
| Code Documentation | 25%    |
| User Experience    | 25%    |
| Code Quality       | 20%    |

---

## Tips for Success

1. **Start with the Dashboard** - Get the adventure list working first
2. **Regenerate Types When API Changes** - Run `npm run generate:api` after any Lab 1 API updates
3. **Use the Typed API Client** - The generated `api` client provides full type safety and autocomplete
4. **Handle Loading States** - Show spinners during API calls
5. **Test Error Cases** - What happens when the API is down?
6. **Keep it Simple** - Functionality over fancy visuals

---

## Code Documentation Guidelines

Your code should include:

````typescript
import { api } from "./api/client";

/**
 * Fetches the current adventure state from the API using the typed client.
 *
 * @param adventureId - The unique identifier of the adventure
 * @returns Promise containing the adventure data
 * @throws {ApiError} When the API request fails
 *
 * @example
 * ```ts
 * const adventure = await getAdventure('123');
 * console.log(adventure.currentScene);
 * ```
 */
async function getAdventure(adventureId: string) {
  const { data, error } = await api.GET("/adventures/{id}", {
    params: { path: { id: adventureId } },
  });

  if (error) throw new Error("Failed to fetch adventure");
  return data;
}
````

---

## Resources

- [GitHub Spec Kit Documentation](https://speckit.org/)
- [React Documentation](https://react.dev/)
- [Vue.js Documentation](https://vuejs.org/)
- [Vite Documentation](https://vitejs.dev/)
- [TanStack Query](https://tanstack.com/query)
- [Tailwind CSS](https://tailwindcss.com/)

---

**May your interface be intuitive and your API calls swift! ğŸ®ğŸ“œ**
